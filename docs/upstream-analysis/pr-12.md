# PR #12: fix(getMessage): fall back to HTML body when plain text extraction fails

- **Author**: lihaokun
- **State**: OPEN
- **Files changed**: extension/mcp_server/api.js
- **Additions/Deletions**: +107 / -11

## Summary

This PR addresses the case where `coerceBodyToPlaintext()` throws an exception or returns empty for certain email types, especially forwarded Gmail messages that contain only HTML body parts nested in `multipart/mixed` or `message/rfc822` structures. When the plaintext extraction fails, the PR adds a recursive MIME tree walker (`findBody`) that searches for `text/html` or `text/plain` parts.

Additionally, this PR adds a `bodyIsHtml` boolean field to the `getMessage` response so callers know whether the returned body is HTML or plain text. The PR also includes a separate `markAsRead` tool and applies `sanitizeForJson` to search result fields and getMessage response headers (using `mime2DecodedSubject` etc.), plus adds `ccList` to search results.

## Key Changes (with code snippets where relevant)

### 1. HTML body fallback in getMessage

When `coerceBodyToPlaintext()` fails, the new code walks the MIME tree recursively:

```javascript
if (!body) {
  try {
    function findBody(part) {
      if (part.parts) {
        for (const sub of part.parts) {
          const result = findBody(sub);
          if (result) return result;
        }
      }
      if (part.contentType === "text/html" && part.body) {
        return { text: part.body, isHtml: true };
      }
      if (part.contentType === "text/plain" && part.body) {
        return { text: part.body, isHtml: false };
      }
      return null;
    }
    const found = findBody(aMimeMsg);
    if (found) {
      body = sanitizeForJson(found.text);
      bodyIsHtml = found.isHtml;
    }
  } catch {
    body = "(Could not extract body text)";
  }
}
```

**Key difference from PR #10**: This PR returns raw HTML with a `bodyIsHtml` flag, while PR #10 strips HTML tags to produce plain text. This approach preserves more information but requires callers to handle HTML.

### 2. New markAsRead tool

Adds a batch `markAsRead` tool that accepts an array of `{messageId, folderPath}` objects and marks them read or unread. This duplicates some of the `updateMessage` tool's functionality but operates in batch.

### 3. ccList in search results and sanitizeForJson on headers

The PR also searches the `ccList` field and includes `ccList` in search result output, and wraps all header fields in `sanitizeForJson()`.

## Discussion & Review Comments

No review comments or discussion on this PR.

## Relevance to Our Fork

**HTML body fallback**: Our fork's `getMessage` (line 614-618 in api.js) uses the same `coerceBodyToPlaintext()` call and falls back to `"(Could not extract body text)"` on failure. We do not have an HTML body fallback, so this addresses a real gap.

**markAsRead tool**: Our fork already has `updateMessage` which can mark messages read/unread. The batch approach is different but our existing tool covers the same functionality for single messages.

**ccList in search results**: Our fork does not include `ccList` in search results or search the CC field.

**sanitizeForJson on headers**: Our fork does not wrap search result header fields in `sanitizeForJson()`. Headers with non-ASCII characters could theoretically cause issues, though `mime2Decoded*` properties handle most encoding.

## Integration Recommendation

- **Should integrate**: partial
- **Priority**: medium
- **Effort**: small
- **Notes**: The HTML body fallback logic is valuable and addresses a real gap. However, we should consider the approach from PR #10 (strip HTML to plain text) versus this one (return raw HTML with `bodyIsHtml` flag). The `markAsRead` batch tool is not needed since `updateMessage` covers this. Adding `ccList` to search results is a nice improvement. The `sanitizeForJson` wrapping on headers is defensive but worth considering.

## Related Issues

None explicitly referenced, but relates to the general problem of HTML-only emails being unreadable.
