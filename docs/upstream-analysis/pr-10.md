# PR #10: fix: handle HTML-only emails and Unicode encoding in JSON responses

- **Author**: quittung
- **State**: OPEN
- **Files changed**: extension/mcp_server/api.js
- **Additions/Deletions**: +40 / -4

## Summary

This PR addresses two related reliability issues. First, it adds a fallback for HTML-only emails where `coerceBodyToPlaintext()` fails or returns empty. Unlike PR #12 which returns raw HTML, this PR strips HTML tags to produce readable plain text. Second, it wraps the HTTP response `res.write()` calls with `sanitizeForJson()` to prevent Unicode characters whose low byte equals `0x22` (the `"` character) from corrupting JSON output.

The Unicode fix is particularly interesting: Thunderbird's `httpd.sys.mjs` writes JS string characters as raw bytes (each char code = one byte). Unicode characters above U+007F whose low byte is `0x22` (like the bullet character U+2022) would insert a literal `"` into the byte stream, breaking JSON parsing.

## Key Changes (with code snippets where relevant)

### 1. HTML body fallback with tag stripping

```javascript
if (!body) {
  function findTextPart(part) {
    const ct = (part.contentType || part.type || "").split(";")[0].trim().toLowerCase();
    if (ct === "text/plain" && part.body) return { content: part.body, isHtml: false };
    if (ct === "text/html" && part.body) return { content: part.body, isHtml: true };
    if (part.parts) {
      for (const sub of part.parts) {
        const result = findTextPart(sub);
        if (result) return result;
      }
    }
    return null;
  }
  const found = findTextPart(aMimeMsg);
  if (found) {
    if (found.isHtml) {
      body = sanitizeForJson(
        found.content
          .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "")
          .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "")
          .replace(/<[^>]+>/g, " ")
          .replace(/&nbsp;/g, " ")
          .replace(/&amp;/g, "&")
          .replace(/&lt;/g, "<")
          .replace(/&gt;/g, ">")
          .replace(/&quot;/g, '"')
          .replace(/&#(\d+);/g, (_, n) => String.fromCodePoint(Number(n)))
          .replace(/\s+/g, " ")
          .trim()
      );
    } else {
      body = sanitizeForJson(found.content);
    }
  }
}
if (!body) body = "(Could not extract body text)";
```

### 2. sanitizeForJson on HTTP response writes

```javascript
// Before (vulnerable to Unicode low-byte collision):
res.write(JSON.stringify({ jsonrpc: "2.0", id, result }));

// After:
res.write(sanitizeForJson(JSON.stringify({ jsonrpc: "2.0", id, result })));
```

This wraps the entire JSON response in `sanitizeForJson()`, which pre-encodes non-ASCII characters as UTF-8 byte sequences, preventing the low-byte collision issue.

## Discussion & Review Comments

No review comments or discussion on this PR.

## Relevance to Our Fork

**HTML body fallback**: Our fork has the same gap - `coerceBodyToPlaintext()` failure results in `"(Could not extract body text)"`. This PR's approach of stripping HTML to plain text is simpler for callers than PR #12's approach (returning raw HTML with a `bodyIsHtml` flag).

**sanitizeForJson on res.write()**: Our fork already wraps individual field values in `sanitizeForJson()` but does NOT wrap the final `res.write()` calls. This means header values, folder names, or other unsanitized fields could still cause the low-byte collision issue described in this PR. Our fork's `res.write()` calls on lines 1180 and 1184 are vulnerable.

Looking at our fork's code (line 1180):
```javascript
res.write(JSON.stringify({ jsonrpc: "2.0", id, result }));
```

This is exactly the pattern that this PR fixes.

## Integration Recommendation

- **Should integrate**: yes
- **Priority**: high
- **Effort**: small
- **Notes**: Both fixes address real bugs. The `sanitizeForJson` wrapping on `res.write()` is the more critical fix - it's a one-line change that prevents JSON corruption from any unsanitized field. The HTML body fallback is valuable but should be evaluated against PR #12's approach. PR #10's HTML stripping is simpler for callers but loses formatting. Consider combining: use PR #10's approach for the default body extraction but add PR #12's `bodyIsHtml` flag as metadata. The `findTextPart` function prefers `text/plain` over `text/html` (it returns plain if found first), which is good default behavior.

## Related Issues

Relates to Issue #2 (getMessage JSON parse errors with non-ASCII characters).
